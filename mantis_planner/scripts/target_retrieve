#!/usr/bin/env python2

import sys
from math import *

import roslib
roslib.load_manifest('contrail')
import rospy
import actionlib

import tf2_ros
from std_msgs.msg import Time
from geometry_msgs.msg import TransformStamped, Quaternion

from mantis_planner.msg import ManoeuvreAction, ManoeuvreGoal
from mantis_msgs.msg import Movement

import dynamic_reconfigure.client

global client_move
global done_move

global tfBuffer
global tfln

global tracking_config
global tracking_client

def quaternion_to_rpy(q):
	if not isinstance(q, Quaternion):
		raise TypeError('Input should be a geometry_msgs/Quaternion')

	q2sqr = q.y * q.y;
	t0 = -2.0 * (q2sqr + q.z * q.z) + 1.0
	t1 = 2.0 * (q.x * q.y + q.w * q.z)
	t2 = -2.0 * (q.x * q.z - q.w * q.y)
	t3 = 2.0 * (q.y * q.z + q.w * q.x)
	t4 = -2.0 * (q.x * q.x + q2sqr) + 1.0

	if(t2 > 1.0):
		t2 = 1.0
	elif(t2 < -1.0):
		t2 = -1.0

	roll = atan2(t3, t4);
	pitch = asin(t2);
	yaw = atan2(t1, t0);

	return (roll,pitch,yaw)

def callback_target(msg_in):
	global client_move
	global done_move

	global tfBuffer
	global tfln

	global tracking_config
	global tracking_client

	# Make sure the message is valid
	if (msg_in.data > rospy.Time(0)) and (tracking_config is not None):
		if not done_move:
			rospy.loginfo("Target goal identified, generating retrieval manoeuvre")

			# Get current position and goals
			tf_t = tfBuffer.lookup_transform("map", "target", msg_in.data, rospy.Duration(0.5))
			tf_b = tfBuffer.lookup_transform("map", "mantis_uav", msg_in.data, rospy.Duration(0.5))
			tf_e = tfBuffer.lookup_transform("map", "mantis_uav/end_effector", msg_in.data, rospy.Duration(0.5))

			move = ManoeuvreGoal()

			move.mode = ManoeuvreGoal.MODE_DISCRETE
			move.nominal_velocity = 0.1
			move.nominal_rate = 0.2
			move.nominal_joint_rate = 0.2

			move.joint_names = ["joint_shoulder", "joint_elbow"]

			# Starting position is current end effector position, half stow
			move.movements.append(Movement())
			move.movements[-1].base.position = tf_e.transform.translation
			_, _, move.movements[-1].base.yaw = quaternion_to_rpy(tf_b.transform.rotation)
			move.movements[-1].joints.append(0.78)
			move.movements[-1].joints.append(1.57)

			# Target position is current target pose, unstow
			move.movements.append(Movement())
			move.movements[-1].base.position = tf_t.transform.translation
			_, _, move.movements[-1].base.yaw = quaternion_to_rpy(tf_t.transform.rotation)
			move.movements[-1].joints.append(0.78)
			move.movements[-1].joints.append(0.78)

			rospy.loginfo("Switching to end effector tracking mode")

			tracked_frame = tracking_config.tracked_frame
			tracking_config.tracked_frame = -1
			tracking_client.update_configuration(tracking_config)

			# Send off the collection movement
			rospy.loginfo("Moving to retrieval point")

			client_move.send_goal(move)
			client_move.wait_for_result()

			# XXX: Graps happens here!
			rospy.loginfo("Performing retrieval")
			rospy.sleep(rospy.Duration(5))

			# Return to the starting position
			rospy.loginfo("Moving to diversion point")

			move.movements.reverse()
			client_move.send_goal(move)
			client_move.wait_for_result()

			rospy.sleep(rospy.Duration(2))

			# Switch back to same tracking as started with
			rospy.loginfo("Switching to previous tracking mode")
			tracking_config.tracked_frame = tracked_frame
			tracking_client.update_configuration(tracking_config)

			done_move = True
		else:
			rospy.logwarn("Target already planned for retrieval, ignoring")
	else:
		rospy.logerr("Target retrieve not ready, ignoring target")

def callback_config(config):
	global tracking_config

	tracking_config = config

def main():
	global client_move
	global done_move

	global tfBuffer
	global tfln

	global tracking_config
	global tracking_client

	rospy.init_node('target_retrieve', anonymous=True)

	rospy.loginfo("Loading target retrieve...")

	done_move = False
	sub = rospy.Subscriber("target_found", Time, callback_target)

	client_move = actionlib.SimpleActionClient('manoeuvre', ManoeuvreAction)
	client_move.wait_for_server()

	tfBuffer = tf2_ros.Buffer()
	tfln = tf2_ros.TransformListener(tfBuffer)

	# Need this to switch out to end effector control and back to the previous settings
	tracking_config = None
	tracking_client = dynamic_reconfigure.client.Client("router_base/control_settings", timeout=30, config_callback=callback_config)

	rospy.loginfo("Target retrieve ready!")

	rospy.spin()

if __name__ == '__main__':
	try:
		main()
	except rospy.ROSInterruptException:
		pass
