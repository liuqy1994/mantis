#!/usr/bin/env python2

import sys
from math import *

import roslib
roslib.load_manifest('contrail')
import rospy
import actionlib

import mantis_planner.movement_loader as ml
from contrail.msg import TrajectoryAction, TrajectoryGoal
from mantis_router_joints.msg import JointMovementAction, JointMovementGoal

global pub_wpl
global timer

def timer_callback(e):
	global pub_wpl
	global timer

	if e.current_real > rospy.Time(0):
		if rospy.has_param("~duration"):
			movement_duration = rospy.Duration.from_sec(rospy.get_param("~duration"))
			success, movements, joint_names = ml.load_movements()

			if success and (len(movements) >= 2):
				rospy.loginfo("Loaded %i movement points for the base and %i joints" % (len(movements), len(joint_names)))
				action_topic_contrail = rospy.get_param("~action_topic_contrail", 'contrail')
				action_topic_joints = rospy.get_param("~action_topic_joint_prefix", "router_joints/")

				# Wait for the action clients to come online
				action_client_joints = []
				client_base = actionlib.SimpleActionClient(action_topic_contrail, TrajectoryAction)
				rospy.loginfo("Waiting for base action client")
				client_base.wait_for_server()

				if not rospy.is_shutdown():
					for j in range(len(joint_names)):
						if not rospy.is_shutdown():
							action_client_joints.append(actionlib.SimpleActionClient(action_topic_joints + joint_names[j], JointMovementAction))
							rospy.loginfo("Waiting for %s action client" % (action_topic_joints + joint_names[j]))
							action_client_joints[j].wait_for_server()

				if not rospy.is_shutdown():
					# Prepare the spline interpolation points
					rospy.loginfo("Continuous manoeuvre:")

					goal_base = TrajectoryGoal()
					goal_base.duration = movement_duration
					goal_base.positions = []
					goal_base.yaws = []
					for i in range(len(movements)):
						goal_base.positions.append(movements[i].base.position)
						goal_base.yaws.append(movements[i].base.yaw)

					# Do some formatted logging to console
					datalog_names = ["Base_Px","Base_Py","Base_Pz","Base_Rz"]
					datalog = []
					datalog_px = []
					datalog_py = []
					datalog_pz = []

					for i in range(len(goal_base.positions)):
						datalog_px.append(goal_base.positions[i].x)
						datalog_py.append(goal_base.positions[i].y)
						datalog_pz.append(goal_base.positions[i].z)

					datalog.append(datalog_px)
					datalog.append(datalog_py)
					datalog.append(datalog_pz)
					datalog.append(goal_base.yaws)

					goal_joints = []
					for j in range(len(joint_names)):
						goal_joints.append(JointMovementGoal())
						goal_joints[j].duration = movement_duration

						goal_joints[j].positions = []
						for i in range(len(movements)):
							goal_joints[j].positions.append(movements[i].joint_positions[j])

						datalog.append(goal_joints[j].positions)
						datalog_names.append(joint_names[j])

					format_title = ""
					format_row = ""
					for i in range(len(datalog_names)):
						format_title += '%' + str(len(datalog_names[i])) + 's '
						format_row += '%' + str(len(datalog_names[i])) + '.4f '

					rospy.loginfo(format_title % tuple(datalog_names))
					for i in range(len(movements)):
						row = []
						for d in range(len(datalog)):
							row.append(datalog[d][i])
						rospy.loginfo(format_row % tuple(row))

					# Prepare the starting time of the action to syncronize clients
					time_start = rospy.Time.now()
					goal_base.start = time_start + rospy.Duration.from_sec(2)
					for j in range(len(joint_names)):
						goal_joints[j].start = time_start + rospy.Duration.from_sec(2)

					# Send out all of the goals in a batch
					client_base.send_goal(goal_base)
					for j in range(len(joint_names)):
						action_client_joints[j].send_goal(goal_joints[j])

					# Wait for a return from the clients
					client_base.wait_for_result()
					for j in range(len(joint_names)):
						action_client_joints[j].wait_for_result()

					# Graceful shutdown if all is successful
					if not rospy.is_shutdown():
						timer.shutdown()
						rospy.signal_shutdown("Continuous movement plan complete!")
			else:
				if (len(wps) < 2):
					rospy.logerr("Not enough movement points were been loaded (%i)" % len(wps))
					rospy.signal_shutdown("Error: <2 movement points")
				else:
					rospy.logerr("Unable to locate movement parameters")
					rospy.signal_shutdown("Error: no movements")
		else:
			rospy.logerr("Unable to locate duration parameter")
			rospy.signal_shutdown("Error: no duration")

def waypoint_pub():
	global timer
	global pub_wpl
	rospy.init_node('discrete_dispatcher', anonymous=True)

	rospy.loginfo("Loading discrete plan dispatcher...")
	timer = rospy.Timer(rospy.Duration(1.0/50.0), timer_callback)

	rospy.spin()

if __name__ == '__main__':
	try:
		waypoint_pub()
	except rospy.ROSInterruptException:
		pass
